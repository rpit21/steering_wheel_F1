<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F1 Steering Wheel Firmware: F1 Steering Wheel ‚Äî Firmware &amp; Simulator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">F1 Steering Wheel Firmware
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">F1 Steering Wheel ‚Äî Firmware &amp; Simulator </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md45">F1 Steering Wheel ‚Äî Firmware &amp; Simulator</a><ul><li class="level2"><a href="#autotoc_md46">üéØ Project Overview</a></li>
<li class="level2"><a href="#autotoc_md47">üß© Dual BSP Design</a></li>
<li class="level2"><a href="#autotoc_md49">üß± Current Status (October 28, 2025)</a></li>
<li class="level2"><a href="#autotoc_md51">üóÇÔ∏è Folder Structure (simplified)</a></li>
<li class="level2"><a href="#autotoc_md52">üß© Code Structure</a></li>
<li class="level2"><a href="#autotoc_md54">üîß Prerequisites</a><ul><li class="level3"><a href="#autotoc_md55">LINUX (Ubuntu):</a></li>
<li class="level3"><a href="#autotoc_md56">WINDOWS (VSCode + MSYS2/UCRT64)</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md59">‚ñ∂Ô∏è Build and Run on PC (host simulator)</a><ul><li class="level3"><a href="#autotoc_md61">DOCUMENTATION</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Comprehensive documentation for the firmware and host simulator of the F1 Steering Wheel project.</p><hr  />
<h1><a class="anchor" id="autotoc_md45"></a>
F1 Steering Wheel ‚Äî Firmware &amp; Simulator</h1>
<p>The <b>F1 Steering Wheel</b> project focuses on designing and developing the firmware of a Formula 1‚Äìstyle steering wheel Board.</p>
<p>It also includes a <b>PC-based simulator</b> for early-stage testing using <b>SDL2</b> (for graphics) and <b>SocketCAN</b> (for CAN bus communication).</p>
<h2><a class="anchor" id="autotoc_md46"></a>
üéØ Project Overview</h2>
<p>The goal of this project is to design and build the electronic board and firmware for a Formula 1 style steering wheel. This simulator allows for the development and testing of the firmware logic on a host PC before deploying it to the target hardware (NXP S32K).</p>
<p>The steering wheel needs to:</p><ul>
<li>Read 4 digital buttons (UP, DOWN, DRS, Pit Limiter).</li>
<li>Read 2 analog inputs (Clutch position, 10-position Rotary Switch).</li>
<li>Communicate with the main ECU via CAN bus, sending input states and receiving vehicle data.</li>
<li>Display information (Temperatures, Statuses) on a 128x64 monochrome display.</li>
<li>Control 2 status LEDs.</li>
</ul>
<h2><a class="anchor" id="autotoc_md47"></a>
üß© Dual BSP Design</h2>
<p>This repository contains the <b>firmware</b> (Target s32k) and the <b>PC simulator</b> (host) for an F1 ‚ÄúSteering Wheel‚Äù board featuring different drivers for:</p>
<ul>
<li>Buttons,</li>
<li>Rotary Switch,</li>
<li>Clutch Signal.</li>
<li>Display (TFT LCD),</li>
<li>CAN Interface.</li>
</ul>
<p>The key idea is to keep <b>the same application code</b> and <b>the same drivers</b>, changing only the <b>HAL (Hardware Abstraction Layer)</b> depending on the target:</p><ul>
<li><code>host_pc</code> ‚Üí runs on LINUX UBUNTU to simulate hardware (keyboard/console/SDL2);</li>
<li><code>target_s32k</code> ‚Üí runs on NXP S32K MCU (integration and linker WIP).</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md49"></a>
üß± Current Status (October 28, 2025)</h2>
<p>The host PC simulator currently implements the following:</p>
<ul>
<li><b>Graphical Display:</b> An SDL2 window simulates the 128x64 monochrome display.</li>
<li><b>Basic Drawing:</b> Functions for clearing the screen, drawing rectangles (filled and outline), and drawing basic text/numbers using an embedded 5x7 font are implemented (<code><a class="el" href="display_8c.html" title="Implementation of the 1-bit-per-pixel monochrome display driver.">drivers/display.c</a></code>).</li>
<li><b>Buttons Input:</b> Keyboard keys '1' through '4' simulate the four digital buttons. Input reading uses Linux terminal functions in non-blocking mode (<code>hal/host_pc/hal_buttons_host.c</code>) and includes debouncing logic (<code><a class="el" href="buttons_8c.html" title="Implementation of the button driver with debounce and callback mechanism.">drivers/buttons.c</a></code>). Visual feedback for button presses is shown on the SDL display.</li>
<li><b>ADC Input Simulation:</b> Rotary switch and clutch inputs are currently simulated with automatically cycling values (defined on <code>adc_data.csv</code>) in <code>hal/host_pc/hal_adc_host.c</code>.</li>
<li><b>CAN Communication:</b><ul>
<li><b>Sending:</b> The simulator sends the <code>SteeringWheel_Status</code> CAN message (ID <code>0x101</code>) whenever the state of the buttons, simulated rotary, or simulated clutch changes. The payload is packed according to the <code>steering_wheel.dbc</code> specification in <code><a class="el" href="can_8c.html" title="Implementation of the high-level CAN communication driver.">drivers/can.c</a></code>. Communication occurs over a virtual CAN interface (<code>vcan0</code>) using SocketCAN (<code>hal/host_pc/hal_can_host.c</code>).</li>
<li><b>Receiving:</b> Basic non-blocking CAN frame reception is implemented (<code>hal_can_receive</code>, <code>canbus_process_incoming</code>),and the logic to <em>decode</em> the <code>ECU_Status_Display</code> message (<code>0x201</code>) it is implemented in <code><a class="el" href="can_8c.html" title="Implementation of the high-level CAN communication driver.">drivers/can.c</a></code>.</li>
</ul>
</li>
<li><b>ECU Simulation (Python):</b> A separate Python script (<code>ecu_sim.py</code>, located in the project root) acts as the simulated ECU. It:<ul>
<li>Listens on the <code>vcan0</code> interface.</li>
<li>Uses the <code>cantools</code> library to decode incoming <code>0x101</code> messages based on <code>steering_wheel.dbc</code>.</li>
<li>Simulates basic vehicle logic (gear changes based on UP/DOWN buttons, Pit Limiter toggle, temperature simulation).</li>
<li>Encodes and sends the <code>ECU_Status_Display</code> message (<code>0x201</code>) periodically, containing the simulated vehicle state.</li>
</ul>
</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md51"></a>
üóÇÔ∏è Folder Structure (simplified)</h2>
<div class="fragment"><div class="line">FIRMWARE/</div>
<div class="line">    app/</div>
<div class="line">        app_main.c|.h</div>
<div class="line">    drivers/</div>
<div class="line">        buttons.c|.h</div>
<div class="line">        can.c|.h</div>
<div class="line">        clutch.c|.h</div>
<div class="line">        display.c|.h</div>
<div class="line">        rotary_switch.c|.h</div>
<div class="line">        TFT_LCD.c|.h</div>
<div class="line">    hal/</div>
<div class="line">        hal_adc.h</div>
<div class="line">        hal_gpio.h</div>
<div class="line">        hal_can.h</div>
<div class="line">        hal_delay.h</div>
<div class="line">        hal_display.h</div>
<div class="line">        hal_lcd.h</div>
<div class="line">        hal_spi.h</div>
<div class="line">        hal.h                     </div>
<div class="line">        host_pc/</div>
<div class="line">            hal_gpio_host.c</div>
<div class="line">            hal_delay_host.c</div>
<div class="line">            hal_display_host.c</div>
<div class="line">            hal_lcd_host.c</div>
<div class="line">            hal_adc_host.c</div>
<div class="line">            hal_can_host              </div>
<div class="line">    test/</div>
<div class="line">        button_test.c, button_test.h</div>
<div class="line">        adc_test.c, adc_test.h</div>
<div class="line">        can_test.c, can_test.h</div>
<div class="line">        display_demo.c, display_demo.h</div>
<div class="line">        adc_data.csv</div>
<div class="line">    ADC_DEVELOPMENT.md</div>
<div class="line">    BUTTON_DEVELOPMENT.md</div>
<div class="line">    CAN_DEVELOPMENT.md</div>
<div class="line">    Doxyfile                                # Configuration for Doxygen documentatio</div>
<div class="line">    ecu_sim.py                              # Python ECU simulator (SocketCAN + cantools)</div>
<div class="line">    main.c</div>
<div class="line">    Makefile                                # build host (sim) and HW placeholder</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md52"></a>
üß© Code Structure</h2>
<p>The firmware follows a layered architecture for better organization, testability, and portability:</p>
<ul>
<li>**<code>app/</code>**: Contains the main application logic (<code><a class="el" href="app__main_8c.html" title="Main application entry point for the F1 Steering Wheel simulator.">app_main.c</a></code>). This layer orchestrates the drivers and implements the high-level behavior of the steering wheel.</li>
<li>**<code>drivers/</code>**: Contains device drivers that provide a higher-level interface to peripherals, handling tasks like debouncing (<code><a class="el" href="buttons_8c.html" title="Implementation of the button driver with debounce and callback mechanism.">buttons.c</a></code>), drawing primitives (<code><a class="el" href="display_8c.html" title="Implementation of the 1-bit-per-pixel monochrome display driver.">display.c</a></code>), processing analog inputs (<code><a class="el" href="clutch_8c.html" title="Implementation of the clutch pedal position driver.">clutch.c</a></code>), and managing CAN message packing/unpacking (<code>canbus.c</code>). Drivers use the HAL.</li>
<li>**<code>hal/</code>**: The Hardware Abstraction Layer.<ul>
<li>Contains generic header files (<code>hal_*.h</code>) defining the interface for each peripheral (buttons, display, ADC, CAN).</li>
<li>Contains subdirectories for each target platform:<ul>
<li>**<code>hal/host_pc/</code>**: Implementation of the HAL functions for the host PC simulation (using SDL2, Linux terminal I/O, SocketCAN).</li>
<li>**<code>hal/target_s32k/</code>**: (Currently contains placeholders) Implementation of the HAL functions for the NXP S32K microcontroller, using its specific SDK/registers.</li>
</ul>
</li>
</ul>
</li>
<li>**<code>test/</code>**: Contains isolated test code for specific modules (currently compiled but not linked into the main simulator executable).</li>
<li>**<code><a class="el" href="main_8c.html" title="Entry point of the F1 Steering Wheel Simulator application.">main.c</a></code>**: The C standard entry point. Initializes the program and calls <code><a class="el" href="app__main_8c.html#a630544a7f0a2cc40d8a7fefab7e2fe70" title="Main application function for steering wheel simulation.">app_main()</a></code>.</li>
<li>**<code>Makefile</code>**: The build script used to compile and link the code using <code>make</code>.</li>
<li>**<code>steering_wheel.dbc</code>**: The CAN database file defining the messages and signals used for communication.</li>
<li>**<code>ecu_sim.py</code>**: Python Script thar simulates an ECU for receiving the status of the Steering Wheel and sending a feedback by CAN</li>
<li>**<code>Doxyfile</code>**: File for the compilation of Doxygen for generating code's documentation.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md54"></a>
üîß Prerequisites</h2>
<h3><a class="anchor" id="autotoc_md55"></a>
LINUX (Ubuntu):</h3>
<p>To compile and run this simulator is highly recommended setup a Linux environment with Ubuntu.</p>
<p>1) Install natively Ubuntu or use a Virtual Machine (Virtual Box)</p>
<p>2) Install toolchain and libraries by opening a terminal </p><div class="fragment"><div class="line">sudo apt update</div>
<div class="line">sudo apt upgrade</div>
<div class="line">sudo apt install build-essential pkg-config can-utils libsdl2-dev python3-pip python3-venv</div>
</div><!-- fragment --><ul>
<li><code>build-essential</code>: Installs <code>gcc</code>, <code>make</code>, and other core development tools.</li>
<li><code>pkg-config</code>: Used by the Makefile to find SDL2 flags.</li>
<li><code>can-utils</code>: Provides command-line tools like <code>candump</code> for interacting with CAN interfaces.</li>
<li><code>libsdl2-dev</code>: Development headers and libraries for SDL2 graphics.</li>
<li><code>python3-pip</code>: Package installer for Python.</li>
<li><code>python3-venv</code>: Tool for creating Python virtual environments.</li>
</ul>
<p>3) Navigate to the <code>F1_Project</code> folder and set up Python Virtual Environment and Packages: </p><div class="fragment"><div class="line">python3 -m venv .venv  #create an virtual environment</div>
<div class="line">source .venv/bin/activate #Activate the environment (Do it every time)</div>
<div class="line">pip pip install python-can cantools #Install Python Libraries</div>
</div><!-- fragment --><p> 4) Git configuration &gt;Configure your Git identity (use the same name/email as your GitHub account):</p>
<div class="fragment"><div class="line">git config --global user.name &quot;Your GitHub Username&quot;</div>
<div class="line">git config --global user.email &quot;your_github_email@example.com&quot;</div>
</div><!-- fragment --><p>&gt;Configure Git to handle line endings correctly when interacting with files potentially edited on Windows</p>
<div class="fragment"><div class="line">git config --global core.autocrlf input</div>
</div><!-- fragment --><p>&gt;Configure Git to ignore file permission changes, which can cause noise when working on mounted Windows filesystems:</p>
<div class="fragment"><div class="line">git config --global core.fileMode false</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md56"></a>
WINDOWS (VSCode + MSYS2/UCRT64)</h3>
<p>1) <b>MSYS2</b> installed in <code>C:\msys64</code> <br  />
 2) Open the <b>MSYS2 UCRT64</b> terminal in VSCode (custom profile):</p><ul>
<li>User settings ‚Üí <code>settings.json</code> <br  />
 <code>json "terminal.integrated.profiles.windows": { "MSYS2 UCRT64": { "path": "C:\\msys64\\usr\\bin\\bash.exe", "args": ["-l","-i"], "env": { "MSYSTEM": "UCRT64", "CHERE_INVOKING": "1" }, "icon": "terminal-bash" } }, "terminal.integrated.defaultProfile.windows": "MSYS2 UCRT64" </code> 3) Install toolchain and libraries (from UCRT64): <code>bash pacman -Syu @section autotoc_md57 restart UCRT64 if prompted pacman -S --needed mingw-w64-ucrt-x86_64-gcc mingw-w64-ucrt-x86_64-pkgconf make </code> (SDL2 will be useful when the display via SDL is completed; for now it‚Äôs optional) 4) Verify: <code>bash echo $MSYSTEM # UCRT64 which gcc # /ucrt64/bin/gcc which make # /ucrt64/bin/make </code> 5) IntelliSense (optional but recommended): create <code>.vscode/c_cpp_properties.json</code> and point to UCRT64 includes (gcc and standard headers).</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md59"></a>
‚ñ∂Ô∏è Build and Run on PC (host simulator)</h2>
<p>Enter the <code>FIRMWARE/</code> folder and run: </p><div class="fragment"><div class="line">cd FIRMWARE</div>
<div class="line">make sim   # build host (default)</div>
<div class="line">make hw    # placeholder for S32K (linker and startup WIP)</div>
<div class="line">make run   # to run the code</div>
<div class="line">make clean # clean up</div>
</div><!-- fragment --><p><b>Only</b> In case that you are going to use any application with <b>CAN</b> follow the next steps : </p><blockquote class="doxtable">
<p>&zwj;ONLY FOR UBUNTU OS!!!!! </p>
</blockquote>
<ol type="1">
<li>Create the Virtual CAN Network:</li>
</ol>
<div class="fragment"><div class="line">sudo modprobe vcan</div>
<div class="line">sudo ip link add dev vcan0 type vcan</div>
<div class="line">sudo ip link set up vcan0</div>
</div><!-- fragment --><ol type="1">
<li>Compilate the FIRMWARE and execute it</li>
</ol>
<div class="fragment"><div class="line">make sim</div>
<div class="line">make run</div>
</div><!-- fragment --><ol type="1">
<li>Executes the simulated ECU --&gt; Python script (ecu_sim.py)</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;In a new terminal activate the virtual environment and executes the .py: </p>
</blockquote>
<div class="fragment"><div class="line">source .venv/bin/activate</div>
<div class="line">python ecu_sim.py</div>
</div><!-- fragment --><ol type="1">
<li>(OPTIONAL) Monitor the CAN BUS</li>
</ol>
<blockquote class="doxtable">
<p>&zwj;Open a new terminal </p>
</blockquote>
<div class="fragment"><div class="line">candump vcan0</div>
</div><!-- fragment --><p>The current test program runs <code><a class="el" href="app__main_8c.html#a630544a7f0a2cc40d8a7fefab7e2fe70" title="Main application function for steering wheel simulation.">app_main()</a></code> (see <code><a class="el" href="main_8c.html" title="Entry point of the F1 Steering Wheel Simulator application.">main.c</a></code>)</p>
<hr  />
<h3><a class="anchor" id="autotoc_md61"></a>
DOCUMENTATION</h3>
<div class="fragment"><div class="line">button_test() ‚Üí buttons_init() ‚Üí hal_buttons_init()</div>
<div class="line"> </div>
<div class="line">loop:</div>
<div class="line">    raw = hal_buttons_read()   // raw read (1‚Äì4 from keyboard)</div>
<div class="line">    stable = buttons_getStable() // debounce filter</div>
<div class="line">    printf(raw, stable)</div>
</div><!-- fragment --><p>For detailed notes on each driver implementation, see:</p>
<p><a class="el" href="ADC_DEVELOPMENT.html">ADC Development Notes</a></p>
<p>Button Driver Notes</p>
<p>CAN Driver Notes</p>
<p>Display Driver Notes</p>
<p>These Markdown documents describe each module‚Äôs design, behavior, and testing strategy. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
